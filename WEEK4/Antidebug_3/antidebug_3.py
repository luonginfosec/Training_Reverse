byte_404118 = [
  0x74, 0x6F, 0x69, 0x35, 0x4F, 0x65, 0x6D, 0x32, 0x32, 0x79, 
  0x42, 0x32, 0x71, 0x55, 0x68, 0x31, 0x6F, 0x5F, 0xDB, 0xCE, 
  0xC9, 0xEF, 0xCE, 0xC9, 0xFE, 0x92, 0x5F, 0x10, 0x27, 0xBC, 
  0x09, 0x0E, 0x17, 0xBA, 0x4D, 0x18, 0x0F, 0xBE, 0xAB, 0x5F, 
  0x9C, 0x8E, 0xA9, 0x89, 0x98, 0x8A, 0x9D, 0x8D, 0xD7, 0xCC, 
  0xDC, 0x8A, 0xA4, 0xCE, 0xDF, 0x8F, 0x81, 0x89, 0x5F, 0x69, 
  0x37, 0x1D, 0x46, 0x46, 0x5F, 0x5E, 0x7D, 0x8A, 0xF3, 0x5F, 
  0x59, 0x01, 0x57, 0x67, 0x06, 0x41, 0x78, 0x01, 0x65, 0x2D, 
  0x7B, 0x0E, 0x57, 0x03, 0x68, 0x5D, 0x07, 0x69, 0x23, 0x55, 
  0x37, 0x60, 0x14, 0x7E, 0x1D, 0x2F, 0x62, 0x5F, 0x62, 0x5F
]

# Step 1: XOR the first 17 bytes with 1
for i in range(0, 17):
    byte_404118[i] ^= 1

# Step 2: XOR bytes 18-25 with 0xAB
for i in range(18, 26):
    byte_404118[i] ^= 0xAB

# Step 3: Transform bytes 0-11 using values from 27-38
j = 0
for i in range(27, 39):
    #   *(*a1 + j) = ((2 * *(*a1 + j)) | 1) ^ (j + 0xCD);
    offset = j + 0xCD
    val = byte_404118[i] ^ offset
    val = val & ~1  
    byte_404118[i] = val // 2
    j+=1

# Step 4: XOR bytes 40-57 in pairs
key = [0xEF,0xBE]
for i in range(40, 58, 2):
    byte_404118[i] ^= key[0]
    byte_404118[i+1] ^= key[1]

# Step 5: Circular bit shift left with j = 1..5
j = 0
for i in range(59, 64):
    # or      edx, eax                ; edx = (byte >> index) | (byte << (8 - index))
    byte_404118[i] = ((byte_404118[i] << j) & 0xFF) | ((byte_404118[i] >> (8 - j)) & 0xFF)
    j += 1

# Step 6: XOR specific bytes with constants
i = 65
key1 = [0x37,0x13,0xFE,0xC0]
byte_404118[i] ^= key1[0]
i += 1
byte_404118[i] ^= key1[1]
i += 1
byte_404118[i] ^= key1[2]
i += 1
byte_404118[i] ^= key1[3]

# Step 7: XOR from end to beginning (indexes 99 â†’ 71)
for i in range(99, 70, -1):
    byte_404118[i] ^= byte_404118[i - 1]

# Final: Print all bytes as characters
print("".join(chr(b) for b in byte_404118))
